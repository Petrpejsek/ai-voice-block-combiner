"""
Integraƒçn√≠ test pro Archive Downloader + Compiler pipeline

Test flow:
1. Vezme sample tts_ready_package (nebo vygeneruje jednoduch√Ω)
2. Spust√≠ FDA ‚Üí ƒçist√Ω shot_plan (BEZ assets/URLs/IDs)
3. Spust√≠ AAR ‚Üí archive_manifest.json (separ√°tn√≠ artefakt)
4. Spust√≠ CB ‚Üí final video (ƒçte manifest)
5. Ovƒõ≈ô√≠ v√Ωstupy:
   - FDA neobsahuje ≈æ√°dn√© URL/ID
   - Manifest vznik√° a≈æ v AAR
   - CB ƒçte manifest (ne shot_plan)
"""

import json
import os
import sys
import tempfile
from datetime import datetime

# Add parent dir to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from footage_director import run_fda_llm, validate_and_fix_shot_plan, validate_shot_plan_hard_gate
from archive_asset_resolver import resolve_shot_plan_assets
from compilation_builder import build_episode_compilation


def create_sample_tts_ready_package():
    """Vytvo≈ô√≠ testovac√≠ TTS package (56s target)"""
    return {
        "episode_id": "test_episode_001",
        "language": "en-US",
        "tts_segments": [
            {
                "segment_id": "tts_001",
                "block_id": "b_0001",
                "text": "World War Two began in 1939.",
                "tts_formatted_text": "World War Two began in 1939.",
                "pause_before_ms": 0,
                "pause_after_ms": 600,
                "metadata": {
                    "speaking_rate": "normal",
                    "emphasis": "none",
                    "notes": ""
                }
            },
            {
                "segment_id": "tts_002",
                "block_id": "b_0002",
                "text": "The conflict involved most of the world's nations.",
                "tts_formatted_text": "The conflict involved most of the world's nations.",
                "pause_before_ms": 600,
                "pause_after_ms": 600,
                "metadata": {
                    "speaking_rate": "normal",
                    "emphasis": "none",
                    "notes": ""
                }
            },
            {
                "segment_id": "tts_003",
                "block_id": "b_0003",
                "text": "It was the deadliest conflict in human history.",
                "tts_formatted_text": "It was the deadliest conflict in human history.",
                "pause_before_ms": 600,
                "pause_after_ms": 1200,
                "metadata": {
                    "speaking_rate": "normal",
                    "emphasis": "moderate",
                    "notes": ""
                }
            },
            {
                "segment_id": "tts_004",
                "block_id": "b_0004",
                "text": "The war ended in 1945 with Allied victory.",
                "tts_formatted_text": "The war ended in 1945 with Allied victory.",
                "pause_before_ms": 1200,
                "pause_after_ms": 600,
                "metadata": {
                    "speaking_rate": "normal",
                    "emphasis": "none",
                    "notes": ""
                }
            }
        ],
        "total_segments": 4,
        "estimated_duration_seconds": 20
    }


def test_fda_step(script_state: dict, provider_api_keys: dict):
    """
    Test FDA (Footage Director) krok.
    Oƒçek√°v√°: ƒåIST√ù shot_plan BEZ assets[], compile_plan, URL/ID
    """
    print("\n" + "="*70)
    print("TEST 1: FDA (Footage Director Assistant)")
    print("="*70)
    
    try:
        raw_llm_json, raw_text, metadata = run_fda_llm(
            script_state,
            provider_api_keys,
            config={
                "provider": "openai",
                "model": "gpt-4o-mini",
                "temperature": 0.2
            }
        )

        # Canonicalize + hard gate (validate the SAME wrapper we would save)
        tts_pkg = script_state.get("tts_ready_package") or {}
        fixed_wrapper, validation_errors = validate_and_fix_shot_plan(raw_llm_json, tts_pkg, words_per_minute=150, auto_fix=False)
        validate_shot_plan_hard_gate(fixed_wrapper, tts_pkg, episode_id=tts_pkg.get("episode_id"))
        shot_plan = fixed_wrapper["shot_plan"]
        
        # Validace v√Ωstupu - z√°kladn√≠ struktura
        assert "scenes" in shot_plan, "‚ùå Missing 'scenes' in shot_plan"
        assert len(shot_plan["scenes"]) > 0, "‚ùå No scenes generated"
        
        # ‚úÖ KONTROLA: FDA NESM√ç obsahovat compile_plan
        assert "compile_plan" not in shot_plan, "‚ùå FDA must NOT contain 'compile_plan' (this is generated by AAR)"
        
        # ‚úÖ KONTROLA: FDA NESM√ç obsahovat assets[] v scenes
        forbidden_fields = ["assets", "archive_item_id", "asset_url", "download_url", "manifest"]
        for scene in shot_plan["scenes"]:
            for field in forbidden_fields:
                assert field not in scene, f"‚ùå FDA scene must NOT contain '{field}' (this is generated by AAR)"
            
            # ‚úÖ KONTROLA: Scene m√° search_queries (to je OK)
            assert "search_queries" in scene, f"‚ùå Scene {scene.get('scene_id')} missing 'search_queries'"
            assert len(scene["search_queries"]) > 0, f"‚ùå Scene {scene.get('scene_id')} has empty search_queries"
        
        # ‚úÖ KONTROLA: ≈Ω√°dn√© URL nebo ID v cel√©m shot_plan
        shot_plan_str = json.dumps(shot_plan)
        assert "archive.org" not in shot_plan_str.lower(), "‚ùå FDA must NOT contain archive.org URLs"
        assert "archive_item_id" not in shot_plan_str, "‚ùå FDA must NOT contain archive_item_id"
        assert "asset_url" not in shot_plan_str, "‚ùå FDA must NOT contain asset_url"
        
        print(f"‚úÖ FDA: Generated clean shot_plan (no assets/URLs/IDs)")
        print(f"   - Total scenes: {shot_plan.get('total_scenes', len(shot_plan['scenes']))}")
        print(f"   - Duration: {shot_plan['scenes'][-1].get('end_sec', 0)}s")
        print(f"   - Search queries per scene: {[len(s.get('search_queries', [])) for s in shot_plan['scenes']]}")
        
        return shot_plan
    
    except Exception as e:
        print(f"‚ùå FDA test failed: {e}")
        raise


def test_aar_step(shot_plan: dict, cache_dir: str, manifest_output_path: str):
    """
    Test AAR (Archive Asset Resolver) krok.
    Oƒçek√°v√°: archive_manifest.json s naplnƒõn√Ωmi assets[]
    """
    print("\n" + "="*70)
    print("TEST 2: AAR (Archive Asset Resolver)")
    print("="*70)
    
    try:
        manifest_dict, manifest_path = resolve_shot_plan_assets(
            shot_plan,
            cache_dir=cache_dir,
            manifest_output_path=manifest_output_path,
            throttle_delay_sec=0.5
        )
        
        # ‚úÖ KONTROLA: Manifest file existuje
        assert os.path.exists(manifest_path), f"‚ùå Manifest file not created: {manifest_path}"
        
        # ‚úÖ KONTROLA: Manifest m√° spr√°vnou strukturu
        assert "version" in manifest_dict, "‚ùå Manifest missing 'version'"
        assert "compile_plan" in manifest_dict, "‚ùå Manifest missing 'compile_plan'"
        assert "scenes" in manifest_dict, "‚ùå Manifest missing 'scenes'"
        
        # ‚úÖ KONTROLA: compile_plan je v manifestu (ne v shot_plan)
        cp = manifest_dict["compile_plan"]
        assert "target_fps" in cp, "‚ùå compile_plan missing 'target_fps'"
        assert "resolution" in cp, "‚ùå compile_plan missing 'resolution'"
        
        # ‚úÖ KONTROLA: Scenes maj√≠ assets s URL/ID
        total_assets = 0
        for scene in manifest_dict["scenes"]:
            assets = scene.get("assets", [])
            assert len(assets) > 0, f"‚ùå Scene {scene.get('scene_id')} has no assets"
            
            for asset in assets:
                # Ovƒõ≈ô ≈æe m√° v≈°echny povinn√© kl√≠ƒçe
                assert "archive_item_id" in asset, "‚ùå Asset missing archive_item_id"
                assert "asset_url" in asset, "‚ùå Asset missing asset_url"
                assert "priority" in asset, "‚ùå Asset missing priority"
            
            total_assets += len(assets)
        
        # ‚úÖ KONTROLA: Manifest obsahuje URL/ID (to je OK - vznik√° a≈æ v AAR)
        manifest_str = json.dumps(manifest_dict)
        assert "archive.org" in manifest_str.lower() or "archive_item_id" in manifest_str, "‚ùå Manifest should contain archive URLs/IDs"
        
        print(f"‚úÖ AAR: Generated archive_manifest.json")
        print(f"   - Manifest path: {manifest_path}")
        print(f"   - Total assets: {total_assets}")
        print(f"   - Compile plan: {cp.get('resolution')} @ {cp.get('target_fps')}fps")
        print(f"   - Cache dir: {cache_dir}")
        
        return manifest_dict, manifest_path
    
    except Exception as e:
        print(f"‚ùå AAR test failed: {e}")
        raise


def test_cb_step(manifest_path: str, episode_id: str, storage_dir: str, output_dir: str):
    """
    Test CB (Compilation Builder) krok.
    Oƒçek√°v√°: fin√°ln√≠ video soubor z manifestu
    """
    print("\n" + "="*70)
    print("TEST 3: CB (Compilation Builder)")
    print("="*70)
    
    try:
        # ‚úÖ KONTROLA: Manifest existuje p≈ôed CB
        assert os.path.exists(manifest_path), f"‚ùå Manifest file not found: {manifest_path}"
        
        output_video, metadata = build_episode_compilation(
            manifest_path=manifest_path,
            episode_id=episode_id,
            storage_dir=storage_dir,
            output_dir=output_dir,
            target_duration_sec=None
        )
        
        # Validace
        if output_video is None:
            print(f"‚ö†Ô∏è  CB: Compilation returned None (mo≈æn√° fallback assety)")
            print(f"    Error: {metadata.get('error', 'Unknown')}")
            return None, metadata
        
        assert os.path.exists(output_video), f"‚ùå Output video not found: {output_video}"
        
        file_size = os.path.getsize(output_video)
        assert file_size > 0, f"‚ùå Output video is empty"
        
        print(f"‚úÖ CB: Compilation complete")
        print(f"   - Output: {output_video}")
        print(f"   - Size: {file_size / (1024*1024):.2f} MB")
        print(f"   - Clips used: {metadata.get('clips_used', 0)}")
        
        return output_video, metadata
    
    except Exception as e:
        print(f"‚ùå CB test failed: {e}")
        raise


def main():
    """Hlavn√≠ test runner"""
    print("\n" + "="*70)
    print("ARCHIVE DOWNLOADER + COMPILER - INTEGRATION TEST")
    print("="*70)
    
    # Kontrola ENV
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("‚ùå OPENAI_API_KEY not set in environment")
        print("   Export your API key: export OPENAI_API_KEY=sk-...")
        return 1
    
    provider_api_keys = {
        "openai": api_key
    }
    
    # Vytvo≈ô temp dirs
    with tempfile.TemporaryDirectory() as temp_dir:
        cache_dir = os.path.join(temp_dir, "archive_cache")
        storage_dir = os.path.join(temp_dir, "assets")
        output_dir = os.path.join(temp_dir, "output")
        
        os.makedirs(cache_dir, exist_ok=True)
        os.makedirs(storage_dir, exist_ok=True)
        os.makedirs(output_dir, exist_ok=True)
        
        print(f"\nüìÅ Test directories:")
        print(f"   - Cache: {cache_dir}")
        print(f"   - Storage: {storage_dir}")
        print(f"   - Output: {output_dir}")
        
        # Vytvo≈ô sample TTS package
        tts_package = create_sample_tts_ready_package()
        episode_id = tts_package["episode_id"]
        
        script_state = {
            "episode_id": episode_id,
            "tts_ready_package": tts_package
        }
        
        try:
            # Test 1: FDA
            shot_plan = test_fda_step(script_state, provider_api_keys)
            
            # Test 2: AAR - generuje manifest
            manifest_output_path = os.path.join(temp_dir, "archive_manifest.json")
            manifest_dict, manifest_path = test_aar_step(shot_plan, cache_dir, manifest_output_path)
            
            # Test 3: CB - ƒçte manifest
            output_video, cb_metadata = test_cb_step(manifest_path, episode_id, storage_dir, output_dir)
            
            # Final summary
            print("\n" + "="*70)
            print("üìä TEST SUMMARY")
            print("="*70)
            print(f"‚úÖ FDA: Clean shot_plan generated (no assets/URLs/IDs)")
            print(f"‚úÖ AAR: Manifest generated with {sum(len(s.get('assets', [])) for s in manifest_dict.get('scenes', []))} assets")
            print(f"   - Manifest: {manifest_path}")
            
            if output_video:
                print(f"‚úÖ CB: Video compiled successfully from manifest")
                print(f"   Output: {output_video}")
            else:
                print(f"‚ö†Ô∏è  CB: Video compilation skipped (fallback assets)")
            
            print("\nüéâ Integration test PASSED")
            print("   ‚úÖ FDA contains NO URLs/IDs (clean shot_plan)")
            print("   ‚úÖ Manifest generated by AAR (separate artifact)")
            print("   ‚úÖ CB reads manifest (not shot_plan)")
            return 0
        
        except Exception as e:
            print(f"\n‚ùå Integration test FAILED: {e}")
            import traceback
            traceback.print_exc()
            return 1


if __name__ == "__main__":
    sys.exit(main())

